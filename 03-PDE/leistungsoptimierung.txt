Berechnungszeit:    12.012234 s 
Berechnungsmethode: Jacobi
Interlines:         64
Stoerfunktion:      f(x,y)=0
Terminierung:       Anzahl der Iterationen
Anzahl Iterationen: 4000
Norm des Fehlers:   3.47849268315e-04
Matrix:
 4.00000000 3.87500000 3.75000000 3.62500000 3.50000000 3.37500000 3.25000000 3.12500000 3.00000000
 3.87500000 1.04707301 0.55996729 0.52973127 0.51142353 0.49318996 0.48378935 0.81270244 2.87500000
 3.75000000 0.55996729 0.02732141 0.01327936 0.01277477 0.01235397 0.02185978 0.41164133 2.75000000
 3.62500000 0.52973127 0.01327936 0.00009392 0.00004538 0.00007772 0.00962301 0.38360244 2.62500000
 3.50000000 0.51142353 0.01277477 0.00004538 0.00000007 0.00003242 0.00912484 0.36530252 2.50000000
 3.37500000 0.49318995 0.01235397 0.00007772 0.00003242 0.00006153 0.00869762 0.34706113 2.37500000
 3.25000000 0.48378935 0.02185978 0.00962301 0.00912484 0.00869762 0.01639815 0.33546338 2.25000000
 3.12500000 0.81270244 0.41164133 0.38360244 0.36530252 0.34706113 0.33546338 0.57833188 2.12500000
 3.00000000 2.87500000 2.75000000 2.62500000 2.50000000 2.37500000 2.25000000 2.12500000 2.00000000




Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 87.83      4.72     4.72        1     4.72     5.25  calculate
  9.76      5.25     0.53 1077444000     0.00     0.00  getResiduum
  2.42      5.38     0.13        1     0.13     0.13  initMatrices
  0.00      5.38     0.00        4     0.00     0.00  allocateMemory
  0.00      5.38     0.00        1     0.00     0.00  AskParams
  0.00      5.38     0.00        1     0.00     0.00  DisplayMatrix
  0.00      5.38     0.00        1     0.00     0.00  allocateMatrices
  0.00      5.38     0.00        1     0.00     0.00  displayStatistics
  0.00      5.38     0.00        1     0.00     0.00  freeMatrices
  0.00      5.38     0.00        1     0.00     0.00  initVariables


Berechnungszeit:    1.681252 s 
Berechnungsmethode: Jacobi
Interlines:         64
Stoerfunktion:      f(x,y)=0
Terminierung:       Anzahl der Iterationen
Anzahl Iterationen: 4000
Norm des Fehlers:   3.47849268315e-04
Matrix:
 4.00000000 3.87500000 3.75000000 3.62500000 3.50000000 3.37500000 3.25000000 3.12500000 3.00000000
 3.87500000 1.04707301 0.55996729 0.52973127 0.51142353 0.49318996 0.48378935 0.81270244 2.87500000
 3.75000000 0.55996729 0.02732141 0.01327936 0.01277477 0.01235397 0.02185978 0.41164133 2.75000000
 3.62500000 0.52973127 0.01327936 0.00009392 0.00004538 0.00007772 0.00962301 0.38360244 2.62500000
 3.50000000 0.51142353 0.01277477 0.00004538 0.00000007 0.00003242 0.00912484 0.36530252 2.50000000
 3.37500000 0.49318995 0.01235397 0.00007772 0.00003242 0.00006153 0.00869762 0.34706113 2.37500000
 3.25000000 0.48378935 0.02185978 0.00962301 0.00912484 0.00869762 0.01639815 0.33546338 2.25000000
 3.12500000 0.81270244 0.41164133 0.38360244 0.36530252 0.34706113 0.33546338 0.57833188 2.12500000
 3.00000000 2.87500000 2.75000000 2.62500000 2.50000000 2.37500000 2.25000000 2.12500000 2.00000000

Wir haben in Zeile 108 for (i = 0; i < arguments->num_matrices; i++) das kleiner gleich Zeichen zu < gändern, da wir sonnst einen Segregationfault error bekommen haben. In Zeile 154 (getResiduum) haben wir den Pointer entfernt, da er nicht benötigt wird und im alten Code nicht gefreet wird und durch die for schleifen einen großen Leak verursacht hat. In calculate haben wir das if statement
  if (i == 1 && j == 1) 
{
   results->stat_precision = 0;
}

aus der for loop entfernt da diese Bedingung nur zum Start auftritt und unnötig oft geprüft wird.

Außerdem haben wir in der Makefile die flag O0 zu O3 geändert, was eine höheres Level an Optimierung bringt.

